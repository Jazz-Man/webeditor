var pgIdCount = 0;
var pgObjectCount = 0;
var pgIdRegExp = new RegExp('\\s*data\\-pg\\-id="([0-9]+)"', "i");
var pgIdRegExpReplace = new RegExp('\\s*data\\-pg\\-id="[0-9]+"', "ig");
var pgWhiteSpaceRegExp = new RegExp("^[\\s\\n]*$");
var pgSelectorCache = {};
var pgDontFormat = ["p", "span", "bdo", "em", "strong", "dfn", "code", "samp", "kbd", "var", "cite", "abbr", "acronym", "q", "sub", "sup", "tt", "i", "b", "big", "small", "u", "s", "strike", "font", "ins", "del", "pre", "address", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "br"];
var pgDontFormatIfAllChildrenNonFormat = ["a"];
var pgAttributeEncode_re = /"/g;
var pgAttributeDecode_re = /&quot;/g;
var pgEncodeAttribute = function (str) {
    if (str === null)return null;
    return str.replace(pgAttributeEncode_re, "&quot;")
};
var pgDecodeAttribute = function (str) {
    if (typeof str != "string")return str;
    return str.replace(pgAttributeDecode_re, '"')
};
var pgParserException = function (msg, obj) {
    this.message = msg;
    this.name = "pgParserException";
    this.reference = obj
};
var pgParserSourceProblem = function (node, $el, skip_locked) {
    this.message = "Can not edit source node.";
    this.name = "pgParserSourceProblem";
    this.node = node;
    this.$el = $el;
    var list = [];
    this.add = function (obj_type, obj, action, reason, msg) {
        if (!reason)reason = "dynamic";
        list.push({obj_type: obj_type, obj: obj, action: action, reason: reason, msg: msg})
    };
    if (node && !skip_locked) {
        var locked = pinegrow.isElementLocked(node);
        if (locked) {
            this.add("element", $el ? getElementName($el) : "node", "change", "custom", locked)
        }
    }
    this.ok = function () {
        return list.length == 0
    };
    this.toString = function () {
        if (list.length == 0)return null;
        var s = "<ul>";
        for (var i = 0; i < list.length; i++) {
            var msg = "";
            var p = list[i];
            switch (p.obj_type) {
                case"class":
                    msg = "Class <b>" + p.obj + "</b>";
                    break;
                case"element":
                    msg = "Element <b>" + p.obj + "</b>";
                    break
            }
            var reason;
            switch (p.reason) {
                default:
                    reason = "because it was either: <b>added by a script</b>, <b>removed from the page</b> or <b>changed in the code editor without refreshing the page</b>"
            }
            if (p.msg) {
                reason = p.msg
            }
            switch (p.action) {
                case"remove":
                    msg += " can't be <b>removed</b>";
                    break;
                case"add":
                    msg += " can't be <b>added</b>";
                    break;
                case"change":
                    msg += " can't be <b>changed</b>";
                    break;
                case"find":
                    msg += " does't <b>exist in source</b>";
                    break;
                case"duplicate":
                    msg += " cant't be <b>duplicated</b>";
                    break
            }
            msg += " " + reason + ".";
            s += "<li>" + msg + "</li>"
        }
        s += "</ul>";
        return s
    }
};
var pgParserNodeCatalogue = function () {
    var dict = {};
    this.clear = function () {
        dict = {}
    };
    this.add = function (node) {
        var id = node.getId();
        if (id) {
            dict[id] = node
        }
    };
    this.get = function (id) {
        if (id in dict) {
            return dict[id]
        }
        return null
    };
    this.remove = function (node) {
        var id = node.getId();
        if (id && id in dict) {
            if (node.objectCount != dict[id].objectCount)return;
            delete dict[id]
        }
    };
    this.logStat = function () {
        var count = 0;
        for (var k in dict) {
            if (dict.hasOwnProperty(k)) {
                ++count
            }
        }
        console.log("pgParserNodeCatalogue - # objects: " + count)
    }
};
var pgParserNodeCatalogueInstance = new pgParserNodeCatalogue;
var pgGetAttributesStringFilterOutPgIds = function (node, name, value) {
    if (name == "data-pg-id")return null;
    if (value === null)return name;
    return name + '="' + value + '"'
};
var pgCreateNodeFromHtml = function (html) {
    var p = new pgParser;
    p.parse(html);
    if (p.rootNode.children.length != 1) {
        throw new pgParserException("Create node from html failed. Only one node can be created.", html)
    }
    return p.rootNode.children[0]
};
var pgCreateDocumentNode = function (nodeCatalogue) {
    var rootNode = new pgParserNode;
    rootNode.tagName = "document";
    rootNode.rootNode = true;
    rootNode.nodeCatalogue = nodeCatalogue ? nodeCatalogue : pgParserNodeCatalogueInstance;
    rootNode.document = rootNode;
    return rootNode
};
var pgParserNode = function (html) {
    var pgAttr = "data-pg-id";
    this.tagName = null;
    this.tagNameOriginal = null;
    this.textNode = false;
    this.rootNode = false;
    this.attributes = "";
    this.closingTag = null;
    this.closed = false;
    this.selfClosed = false;
    this.content = null;
    this.singleTag = false;
    this.script = false;
    this.children = [];
    this.parent = null;
    this.comment = false;
    this.isElement = false;
    this.pgId = null;
    this.hasPgIdAttr = false;
    this.objectCount = ++pgObjectCount;
    this.data = {};
    this.attrList = null;
    this.attrListChanged = false;
    this.nodeCatalogue = pgParserNodeCatalogueInstance;
    this.document = null;
    this.$el = null;
    var _this = this;
    this.setDocument = function (document) {
        this.walkSelfAndChildren(function (node) {
            node.document = document;
            return true
        })
    };
    this.addChild = function (node) {
        this.children.push(node);
        node.parent = this;
        node.setDocument(this.document)
    };
    this.removeChild = function (node) {
        var idx = this.getChildPos(node);
        if (idx >= 0) {
            this.children.splice(idx, 1)
        }
        node.parent = null;
        node.setDocument(null)
    };
    this.getParent = function () {
        return this.parent
    };
    this.shouldHaveId = function () {
        if (this.script && this.tagName == "?php")return true;
        return this.isElement && !this.script && !this.textNode && !this.comment
    };
    this.getByPgId = function (id) {
        var cat = this.nodeCatalogue ? this.nodeCatalogue : this.document ? this.document.nodeCatalogue : null;
        if (cat)return cat.get(id);
        return null
    };
    this.walk = function (func) {
        for (var i = 0; i < this.children.length; i++) {
            var r = func(this.children[i]);
            if (!r) {
                return
            } else if (r === "skip_children") {
                continue
            }
            this.children[i].walk(func)
        }
    };
    this.walkSelfAndChildren = function (func) {
        if (!func(this))return;
        this.walk(func)
    };
    this.findOne = function (sel) {
        var r = this.find(sel, true);
        return r.length ? r[0] : null
    };
    this.find = function (sel, single) {
        pgSelectorCache = {};
        var sel_list = sel.split(",");
        var results = [];
        for (var i = 0; i < sel_list.length; i++) {
            var path = sel_list[i].split(" ");
            var _this = this;
            this.walk(function (node) {
                if (node.isTo(path, _this)) {
                    if (results.indexOf(node) < 0) {
                        results.push(node)
                    }
                    if (single)return false
                }
                return true
            })
        }
        return results
    };
    this.findOneWithAttrValue = function (attr, value) {
        var list = this.find("[" + attr + "]");
        for (var i = 0; i < list.length; i++) {
            if (list[i].getAttr(attr) == value)return list[i]
        }
        return null
    };
    this.validateTree = function () {
        var invalid = [];
        this.walk(function (node) {
            if (!node.validate())invalid.push(node);
            return true
        });
        return invalid
    };
    this.isTo = function (path, node) {
        var me = path[path.length - 1];
        var immediate = false;
        if (me.charAt(0) == ">") {
            immediate = true;
            me = me.substr(1)
        }
        if (this.isSelector(me)) {
            if (path.length < 2)return true;
            var idx = path.length - 2;
            var parent = this.getParent();
            while (parent && parent != node) {
                var sel = path[idx];
                var next_immediate = false;
                if (sel.charAt(0) == ">") {
                    next_immediate = true;
                    sel = sel.substr(1)
                }
                if (parent.isSelector(sel)) {
                    idx--;
                    if (idx < 0)return true
                } else {
                    if (immediate)return false
                }
                parent = parent.getParent();
                immediate = next_immediate
            }
            return false
        } else {
            return false
        }
    };
    this.parseSelector = function (sel) {
        if (!pgSelectorCache[sel]) {
            var m = sel.match(/\[([^\]]+)\]/);
            var attr = null;
            if (m) {
                attr = m[1];
                sel = sel.replace(m[0], "")
            }
            pgSelectorCache[sel] = {
                id: sel.match(/#[^\s\.]+/),
                tag: sel.match(/^[^\s\.#]+/),
                classes: sel.match(/\.[^\s\.#]+/g),
                attr: attr
            }
        }
        return pgSelectorCache[sel]
    };
    this.isSelector = function (sel, parsed_sel) {
        parsed_sel = parsed_sel || this.parseSelector(sel);
        if (parsed_sel.id) {
            if (this.getElementId() != parsed_sel.id[0].replace("#", ""))return false
        }
        if (parsed_sel.tag) {
            if (parsed_sel.tag != this.tagName)return false
        }
        if (parsed_sel.classes) {
            for (var i = 0; i < parsed_sel.classes.length; i++) {
                if (!this.hasClass(parsed_sel.classes[i].replace(".", "")))return false
            }
        }
        if (parsed_sel.attr) {
            if (!this.hasAttr(parsed_sel.attr))return false
        }
        return true
    };
    this.closest = function (sel) {
        var parsed_sel = this.parseSelector(sel);
        var r = this;
        while (!r.isSelector(sel, parsed_sel)) {
            if (!r.parent)return null;
            r = r.parent
        }
        return r
    };
    this.replaceTag = function (tag) {
        this.tagName = tag;
        this.tagNameOriginal = tag;
        if (this.closingTag) {
            this.closingTag = tag
        }
        return this
    };
    this.replaceWith = function (node, detach) {
        if (!this.parent)return this;
        node.insertBefore(this);
        if (detach) {
            this.detach()
        } else {
            this.remove()
        }
        return this
    };
    this.replaceContent = function (node, detach) {
        while (this.children.length) {
            if (detach) {
                this.children[0].detach()
            } else {
                this.children[0].remove()
            }
        }
        while (node.children.length) {
            this.append(node.children[0])
        }
    };
    this.detag = function () {
        if (this.parent) {
            while (this.children.length) {
                this.children[0].insertBefore(this)
            }
            this.remove()
        }
    };
    this.clone = function (dont_asign_id, copy_ids) {
        var node = new pgParserNode;
        node.tagName = this.tagName;
        node.textNode = this.textNode;
        node.rootNode = this.rootNode;
        node.attributes = this.getAttributesString();
        node.closingTag = this.closingTag;
        node.selfClosed = this.selfClosed;
        node.content = this.content;
        node.singleTag = this.singleTag;
        node.script = this.script;
        node.comment = this.comment;
        node.document = this.document;
        node.nodeCatalogue = this.nodeCatalogue;
        node.isElement = this.isElement;
        node.attrList = null;
        node.hasPgIdAttr = this.hasPgIdAttr;
        node.data = this.data;
        if (!dont_asign_id && node.shouldHaveId()) {
            node.assignId();
            node.nodeCatalogue.add(node)
        }
        if (copy_ids) {
            node.pgId = this.getId()
        }
        for (var n = 0; n < this.children.length; n++) {
            node.addChild(this.children[n].clone(dont_asign_id, copy_ids))
        }
        return node
    };
    this.setData = function (key, value) {
        this.data[key] = value
    };
    this.getData = function (key, default_value) {
        return this.data[key] || default_value || null
    };
    this.html = function (html, withIds) {
        if (typeof html == "undefined" || html === null) {
            if (this.script || this.textNode)return this.content;
            if (this.tagName == "script" || this.tagName == "php")return this.content;
            var s = "";
            for (var i = 0; i < this.children.length; i++) {
                s += this.children[i].toString("", true, withIds)
            }
            return s
        }
        if (this.script) {
            this.content = html
        } else if (this.tagName == "script" || this.tagName == "php" || this.textNode) {
            this.content = html
        } else {
            var p = new pgParser;
            p.parse(html);
            while (this.children.length) {
                this.children[0].remove()
            }
            for (var i = 0; i < p.rootNode.children.length; i++) {
                this.addChild(p.rootNode.children[i])
            }
        }
    };
    this.text = function (html) {
        if (typeof html == "undefined" || html === null) {
            var s = "";
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i].tagName == "text") {
                    s += this.children[i].toString("", true, false)
                } else {
                    s += this.children[i].text()
                }
            }
            return s
        }
        this.html(html)
    };
    this.indentText = function (text, indent, level, html_options) {
        if (indent === null) {
            if (!html_options)html_options = pinegrow.getFormatHtmlOptions();
            if (level === null)level = this.getNestingLevel();
            indent = pinegrow.getHtmlIndentForLevel(level, html_options)
        }
        var lines = text.split("\n");
        var s = "";
        for (var i = 0; i < lines.length; i++) {
            if (i > 0)s += "\n";
            s += i == 0 ? lines[i] : indent + lines[i]
        }
        return s
    };
    this.isDescendantOf = function (ancestor) {
        var p = this.parent;
        while (p != null) {
            if (p == ancestor) {
                return true
            }
            p = p.parent
        }
        return false
    };
    this.getChildPos = function (child) {
        return this.children.indexOf(child)
    };
    this.next = function () {
        var idx = this.parent.getChildPos(this) + 1;
        var next = null;
        while (idx < this.parent.children.length && !next) {
            if (this.parent.children[idx].isElement) {
                next = this.parent.children[idx];
                break
            }
            idx++
        }
        return next
    };
    this.prev = function () {
        var idx = this.parent.getChildPos(this) - 1;
        var prev = null;
        while (idx >= 0 && !prev) {
            if (this.parent.children[idx].isElement) {
                prev = this.parent.children[idx];
                break
            }
            idx--
        }
        return prev
    };
    this.insertAtIndex = function (parent, idx, skip_text) {
        if (parent == this.parent) {
            var i = this.parent.children.indexOf(this);
            if (i < idx)idx--
        }
        this.detach();
        if (skip_text && idx > 0) {
            var num_non_text = 0;
            var nidx = idx;
            for (var i = 0; i < parent.children.length; i++) {
                if (!parent.children[i].shouldHaveId()) {
                    nidx++
                } else {
                    num_non_text++;
                    if (idx == num_non_text)break
                }
            }
            idx = nidx
        }
        if (idx >= parent.children.length) {
            parent.children.push(this)
        } else {
            parent.children.splice(idx, 0, this)
        }
        this.parent = parent;
        this.setDocument(this.parent.document);
        return this
    };
    this.insert = function (dest, before) {
        if (!dest.parent)return;
        var idx = dest.parent.getChildPos(dest);
        if (idx < 0) {
            throw new pgParserException("Node is not in parent child list", dest)
        } else {
            if (before) {
                this.insertAtIndex(dest.parent, idx)
            } else {
                this.insertAtIndex(dest.parent, idx + 1)
            }
        }
        return this
    };
    this.detach = function () {
        if (this.parent) {
            this.parent.removeChild(this)
        }
    };
    this.remove = function () {
        this.detach();
        this.nodeCatalogue.remove(this);
        while (this.children.length) {
            this.children[0].remove()
        }
    };
    this.insertBefore = function (dest) {
        return this.insert(dest, true)
    };
    this.insertAfter = function (dest) {
        return this.insert(dest, false)
    };
    this.appendPrepend = function (dest, prepend) {
        this.detach();
        if (prepend) {
            dest.children.unshift(this)
        } else {
            dest.children.push(this)
        }
        this.parent = dest;
        this.setDocument(this.parent.document);
        return this
    };
    this.appendTo = function (dest) {
        return this.appendPrepend(dest, false)
    };
    this.prependTo = function (dest) {
        return this.appendPrepend(dest, true)
    };
    this.append = function (node) {
        node.appendTo(this)
    };
    this.prepend = function (node) {
        node.prependTo(this)
    };
    this.hasClass = function (cls) {
        var classes = this.getAttr("class");
        if (classes) {
            var list = classes.split(" ");
            var idx = list.indexOf(cls);
            if (idx >= 0)return true
        }
        return false
    };
    this.addClass = function (cls) {
        var classes = this.getAttr("class");
        if (classes) {
            var list = classes.split(" ");
            var idx = list.indexOf(cls);
            if (idx < 0) {
                list.push(cls);
                this.setAttr("class", list.join(" "))
            }
        } else {
            this.setAttr("class", cls)
        }
    };
    this.removeClass = function (cls) {
        var classes = this.getAttr("class");
        if (classes) {
            var list = classes.split(" ");
            var r = [];
            for (var i = 0; i < list.length; i++) {
                if (list[i] != cls) {
                    r.push(list[i])
                }
            }
            this.setAttr("class", r.join(" "))
        }
    };
    this.canAddClass = function (cls) {
        return true
    };
    this.canRemoveClass = function (cls) {
        return this.hasClass(cls)
    };
    this.getAttrList = function () {
        if (this.attrList)return this.attrList;
        this.attrList = [];
        this.attrListChanged = false;
        if (this.script || this.comment || !this.attributes || this.attributes.length == 0)return this.attrList;
        var i = 0;
        var in_name = true;
        var in_value = false;
        var cur_name = "";
        var cur_value = "";
        var in_quote = null;
        var readUntil = function (end_ch, ignore) {
            var idx = _this.attributes.indexOf(end_ch, i);
            do {
                if (idx < 0) {
                    i = _this.attributes.length;
                    return null
                } else {
                    if (ignore) {
                        var ign_idx = _this.attributes.indexOf(ignore, i);
                        if (ign_idx >= 0 && idx >= ign_idx && idx + end_ch.length <= ign_idx + ignore.length) {
                            i = idx + end_ch.length;
                            continue
                        }
                    }
                    var s = _this.attributes.substr(i, idx - i);
                    i = idx + end_ch.length;
                    return s
                }
            } while (i < _this.attributes.length)
        };
        while (i < this.attributes.length) {
            var ch = this.attributes.charAt(i);
            if (ch == " " || ch == "	" || ch == "\n" || ch == "\r" || ch == "/" || ch == ">" || ch == "=") {
                if (cur_name.length > 0) {
                    var has_equal = false;
                    if (i < this.attributes.length - 1) {
                        while (i < this.attributes.length && (ch == " " || ch == "=")) {
                            if (ch == "=")has_equal = true;
                            i++;
                            ch = this.attributes.charAt(i)
                        }
                    }
                    if (has_equal) {
                        in_value = true;
                        if (ch == '"' || ch == "'") {
                            in_quote = ch
                        } else {
                            in_quote = null
                        }
                        var val = "";
                        if (in_quote) {
                            i++;
                            val = readUntil(in_quote)
                        } else {
                            if (i < this.attributes.length - 1) {
                                do {
                                    val += ch;
                                    i++;
                                    ch = this.attributes.charAt(i)
                                } while (i < this.attributes.length && (ch != " " && ch != ">" && ch != "/"))
                            }
                        }
                        this.attrList.push({name: cur_name.toLowerCase(), value: val})
                    } else {
                        i--;
                        this.attrList.push({name: cur_name.toLowerCase(), value: null})
                    }
                    cur_name = ""
                }
            } else {
                cur_name += ch;
                if (cur_name == "<?php") {
                    i++;
                    cur_name += readUntil("?>") + "?>"
                }
            }
            i++
        }
        if (cur_name.length) {
            this.attrList.push({name: cur_name.toLowerCase(), value: null})
        }
        return this.attrList
    };
    this.hasAttr = function (attr) {
        var list = this.getAttrList();
        if (!list)return null;
        var r = findAttrsInList(attr, list);
        if (r.length) {
            return true
        } else {
            return false
        }
    };
    this.findAttributesStartingWith = function (attr) {
        var list = this.getAttrList();
        if (!list)return [];
        var r = [];
        for (var i = 0; i < list.length; i++) {
            if (list[i].name.indexOf(attr) == 0) {
                r.push(list[i])
            }
        }
        return r
    };
    var findAttrsInList = function (attr, list) {
        var r = [];
        attr = attr.toLowerCase();
        for (var i = 0; i < list.length; i++) {
            if (attr == list[i].name) {
                r.push(list[i])
            }
        }
        return r
    };
    this.setAttr = function (attr, value, skip_encode) {
        if (typeof value == "undefined")value = null;
        if (!skip_encode)value = pgEncodeAttribute(value);
        var list = this.getAttrList();
        var r = findAttrsInList(attr, list);
        if (r.length) {
            r[r.length - 1].value = value
        } else {
            list.push({name: attr, value: value})
        }
        this.attrListChanged = true
    };
    this.getAttr = function (attr) {
        var list = this.getAttrList();
        if (!list)return null;
        var r = findAttrsInList(attr, list);
        if (r.length) {
            return pgDecodeAttribute(r[r.length - 1].value)
        } else {
            return null
        }
    };
    this.removeAttr = function (attr) {
        var list = this.getAttrList();
        attr = attr.toLowerCase();
        this.attrList = [];
        for (var i = 0; i < list.length; i++) {
            if (list[i].name != attr) {
                this.attrList.push(list[i])
            }
        }
        if (list.length != this.attrList.length) {
            this.attrListChanged = true
        }
    };
    this.removeAttrIfStartsWith = function (str) {
        var list = this.getAttrList();
        str = str.toLowerCase();
        this.attrList = [];
        for (var i = 0; i < list.length; i++) {
            if (!list[i].name.startsWith(str)) {
                this.attrList.push(list[i])
            }
        }
        if (list.length != this.attrList.length) {
            this.attrListChanged = true
        }
    };
    this.getAttributesString = function (filter_func) {
        if (!this.attrListChanged && !filter_func) {
            return this.attributes
        }
        var o = [];
        var list = this.getAttrList();
        if (filter_func) {
            for (var i = 0; i < list.length; i++) {
                var str = filter_func(this, list[i].name, list[i].value);
                if (str && str.length) {
                    o.push(str)
                }
            }
        } else {
            for (var i = 0; i < list.length; i++) {
                if (list[i].value === null) {
                    o.push(list[i].name)
                } else {
                    o.push(list[i].name + '="' + list[i].value + '"')
                }
            }
        }
        return o.length > 0 ? " " + o.join(" ") : ""
    };
    this.getElementId = function () {
        return this.getAttr("id")
    };
    this.getId = function () {
        if (this.pgId === null && this.attributes) {
            var m = this.attributes.match(pgIdRegExp);
            if (m) {
                this.pgId = m[1];
                this.hasPgIdAttr = true
            } else {
                this.pgId = 0;
                this.hasPgIdAttr = false
            }
        }
        return this.pgId !== 0 ? this.pgId : null
    };
    this.assignId = function () {
        if (this.hasPgIdAttr) {
            this.attributes = this.attributes.replace(pgIdRegExpReplace, "");
            this.hasPgIdAttr = false
        }
        this.pgId = ++pgIdCount;
        return this.pgId
    };
    this.getOrAssignId = function () {
        var id = this.getId();
        if (!id)id = this.assignId();
        return id
    };
    this.assignIdAndAddToCatalog = function (do_subnodes) {
        if (do_subnodes) {
            this.walkSelfAndChildren(function (node) {
                if (node.shouldHaveId()) {
                    var id = node.getOrAssignId();
                    _this.nodeCatalogue.add(node)
                }
                return true
            })
        } else {
            if (this.shouldHaveId()) {
                var id = this.assignId();
                _this.nodeCatalogue.add(this)
            }
        }
    };
    this.get$DOMElement = function ($html) {
        if (this.$el)return this.$el;
        return $html ? $html.find('[data-pg-id="' + this.getId() + '"]') : null
    };
    this.mapIdsToDomElement = function (node) {
        var id = this.getId();
        if (id) {
            node.setAttribute("data-pg-id", id)
        }
        var dom_i = 0;
        var pg_i = 0;
        if (node.hasChildNodes()) {
            for (var i = 0; i < this.children.length; i++) {
                if (!this.children[i].shouldHaveId())continue;
                while (dom_i < node.childNodes.length && node.childNodes[dom_i].nodeType != 1) {
                    dom_i++
                }
                if (dom_i < node.childNodes.length) {
                    this.children[i].mapIdsToDomElement(node.childNodes[dom_i])
                }
                dom_i++
            }
        }
    };
    this.validate = function () {
        if (this.tagName != "text" && (!this.closed || this.closingTag && this.tagName != this.closingTag.toLowerCase())) {
            return false
        }
        return true
    };
    this.getNestingLevel = function () {
        var level = 0;
        var n = this;
        while (n.parent) {
            level++;
            n = n.parent
        }
        return level
    };
    this.getOpeningTag = function () {
        if (this.isElement) {
            return "<" + this.tagName + "" + this.getAttributesString(pgGetAttributesStringFilterOutPgIds) + ">"
        }
        return null
    };
    this.getClosingTag = function () {
        if (this.isElement) {
            return "</" + (this.closingTag ? this.closingTag : this.tagName) + ">"
        }
        return null
    };
    this.getScriptIndent = function () {
        if (!this.script || !this.content)return 0;
        if (this.content.match(/^\s(if|while)/)) {
            return 1
        } else if (this.content.match(/^\s(endif|endwhile)/)) {
            return -1
        } else if (this.content.match(/^\selse/)) {
            return -2
        }
    };
    this.changeToPhp = function (code) {
        this.tagName = "?php";
        this.tagNameOriginal = "?php";
        this.script = true;
        this.isElement = false;
        this.textNode = false;
        this.singleTag = true;
        this.closed = true;
        this.closingTag = null;
        this.content = code;
        this.selfClosed = false
    };
    this.toString = function (pref, showTextNodes, withIds, func, format_html, options, use_pref) {
        pref = pref || "";
        if (!options) {
            options = {indent: "    "}
        }
        if (typeof use_pref == "undefined")use_pref = true;
        var nl = "";
        var enl = "";
        var epref = pref;
        var s = "";
        var pgId = null;
        var pgIdAdd = "";
        var pgIdPrepend = "";
        var indent = options.indent;
        this.attrListChanged = this.isElement;
        if (this.attrListChanged) {
            this.attributes = this.getAttributesString(withIds ? null : pgGetAttributesStringFilterOutPgIds);
            this.attrListChanged = false
        }
        var attrs = this.attributes;
        if (this.script) {
            attrs = this.indent_text ? pgReindentText(this.content, pref + indent) : this.content
        }
        pgId = this.getId();
        var format = format_html && pgDontFormat.indexOf(this.tagName) < 0;
        if (format && pgDontFormatIfAllChildrenNonFormat.indexOf(this.tagName) >= 0) {
            format = false;
            for (var i = 0; i < this.children.length; i++) {
                if (!this.children[i].textNode && pgDontFormat.indexOf(this.children[i].tagName) < 0) {
                    format = true;
                    break
                }
            }
        }
        options.last_format = format;
        var orig_pref = pref;
        var php_ids = false;
        if (format) {
            nl = "\n";
            enl = "\n"
        } else {
        }
        if (pref.length)enl = "\n";
        if (this.rootNode) {
            indent = ""
        }
        if (pgId) {
            if (!withIds) {
                attrs = attrs.replace(pgIdRegExp, "")
            } else {
                if (!this.hasPgIdAttr) {
                    pgIdAdd = " " + pgAttr + '="' + pgId + '"'
                }
            }
        }
        if (pgId === null && withIds && this.isElement) {
            pgId = this.assignId();
            pgIdAdd = " " + pgAttr + '="' + pgId + '"'
        }
        if (pgIdAdd && this.tagName == "?php") {
            if (php_ids)pgIdPrepend = " /*" + pgIdAdd + "*/";
            pgIdAdd = ""
        }
        if (showTextNodes && this.textNode) {
            if (format && this.content.match(pgWhiteSpaceRegExp)) {
                if (this.content.indexOf("\n") >= 0)return "";
                if (this.content.length)return " ";
                return ""
            }
            return this.content
        }
        var content = "";
        var just_text_or_empty = true;
        var prev_is_formatted = false;
        for (var i = 0; i < this.children.length; i++) {
            if (!showTextNodes && this.children[i].textNode)continue;
            just_text_or_empty = just_text_or_empty && this.children[i].textNode;
            var script_indent = this.children[i].getScriptIndent();
            if (script_indent == -1 || script_indent == -2) {
                pref = pref.substr(0, pref.length - options.indent.length)
            }
            var c = this.children[i].toString(pref + indent, showTextNodes, withIds, func, format_html, options, format);
            var child_format = options.last_format;
            var is_text = this.children[i].textNode;
            if (withIds && this.children[i].tagName == "?php" && php_ids) {
                var cpgId = this.children[i].getId();
                c = pref + indent + "<!--[start-pg-id:" + cpgId + "]-->\n" + c + "\n" + pref + indent + "<!--[end-pg-id:" + cpgId + "]-->"
            }
            if (script_indent == 1 || script_indent == -2) {
                pref = pref + options.indent
            }
            if (format) {
                if (c.length) {
                    if (is_text) {
                        if (c.length) {
                            var br = "";
                            if (c.charAt(0) == "\n") {
                                c = c.replace(/^\n\s*/, "");
                                prev_is_formatted = true;
                                br = "\n"
                            }
                            if (prev_is_formatted) {
                                c = br + pref + indent + c;
                                if (i + 1 < this.children.length) {
                                    if (!this.children[i + 1].textNode)c = c + "\n"
                                } else {
                                    c = c + "\n"
                                }
                            }
                        }
                    } else {
                        if (!this.rootNode || content.length) {
                            c = "\n" + c
                        }
                    }
                    prev_is_formatted = child_format
                } else {
                    if (i + 1 == this.children.length) {
                        c = "\n" + c
                    }
                }
            }
            content += c
        }
        if (format && this.children.length && !just_text_or_empty && content.length && !this.rootNode) {
            if (content.charAt(content.length - 1) != "\n") {
                content = content + "\n"
            }
        }
        if (format && just_text_or_empty) {
            nl = "";
            epref = ""
        }
        enl = "";
        options.last_format = format;
        if (attrs.length && func) {
            attrs = func(this, attrs, "attrs")
        }
        if (!this.rootNode) {
            s += (use_pref ? pref : "") + "<" + (this.tagNameOriginal ? this.tagNameOriginal : this.tagName) + pgIdPrepend + attrs + pgIdAdd + (this.selfClosed ? "/" : "") + (this.script && this.tagName == "?php" ? "?" : "") + ">"
        } else {
            return s + content
        }
        if (this.content && !this.script) {
            if (this.tagName == "php") {
                content += pgReindentText(this.content, pref)
            } else {
                content += this.content
            }
        }
        if (func)content = func(this, content, "content");
        if (format) {
            s += content
        } else {
            s += content
        }
        if (!this.singleTag) {
            if (this.closingTag) {
                s += (format ? epref : "") + "</" + this.closingTag + ">" + enl
            } else {
                s += enl
            }
        } else {
            s += enl
        }
        if (func)s = func(this, s, "node");
        return s
    };
    this.toStringOriginal = function (format_html, options, func) {
        return this.toString(null, true, false, func, format_html, options)
    };
    this.toStringWithIds = function (format_html, options, func) {
        return this.toString(null, true, true, func, format_html, options)
    };
    this.toDebug = function () {
        var s = "";
        if (this.textNode) {
            s = "[TEXT] |" + this.content + "|"
        } else if (!this.rootNode) {
            s = this.tagNameOriginal ? this.tagNameOriginal : this.tagName;
            if (this.closed)s += " /" + this.closingTag
        }
        if (this.children.length) {
            s += "<ul>";
            for (var i = 0; i < this.children.length; i++) {
                s += this.children[i].toDebug()
            }
            s += "</ul>"
        }
        if (this.rootNode)return s;
        return "<li>" + s + "</li>"
    }
};
var pgParser = function () {
    var source = null;
    this.singleTags = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr", "!", "?php", "!doctype"];
    this.closingTags = {
        html: [],
        head: ["body"],
        body: [],
        p: ["p", "address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "menu", "nav", "ol", "pre", "section", "table", "ul"],
        dd: ["dd"],
        dt: ["dt"],
        option: ["option", "optgroup"],
        optgroup: ["optgroup"],
        thead: ["tbody", "tfoot"],
        th: ["td", "th"],
        tbody: ["tfoot"],
        tr: ["tr"],
        td: ["td", "th"],
        tfoot: ["tbody"],
        colgroup: [],
        li: ["li"]
    };
    var _this = this;
    this.assignIds = true;
    var tokenGetTagNameState = 0;
    var tokenGetTagNameRe = /[a-z0-9\?!:\-]/i;
    var tokenGetTagName = function (ch, s) {
        if (s.length == 0) {
            tokenGetTagNameState = 0;
            if (ch == "/")return true
        }
        if (tokenGetTagNameState == 0) {
            if (ch == "!") {
                tokenGetTagNameState = 1
            }
        }
        if (tokenGetTagNameState == 1) {
            if (s == "!--")return false
        }
        return ch.match(tokenGetTagNameRe)
    };
    var tokenGetTagAttributes = function (ch) {
        return ch != ">"
    };
    this.replaceExistingIds = false;
    this.nodeCatalogue = pgParserNodeCatalogueInstance;
    this.rootNode = null;
    this.getNode = function (id) {
        return this.nodeCatalogue.get(id)
    };
    this.parse = function (s, done, chunkDone) {
        source = s;
        var _this = this;
        var nodeLevels = [];
        this.rootNode = new pgParserNode;
        this.rootNode.tagName = "document";
        this.rootNode.rootNode = true;
        this.rootNode.nodeCatalogue = this.nodeCatalogue;
        this.rootNode.document = this.rootNode;
        this.replacedIds = [];
        var len = source.length;
        var currentNode = this.rootNode;
        var node = null;
        var i = 0;
        var startsWith = function (token) {
            for (var n = 0; n < token.length; n++) {
                if (i + n >= len || token.charAt(n) != source.charAt(i + n))return false
            }
            return true
        };
        var readToken = function (func, parse_quotes, attr_mode) {
            var s = "";
            var start_script = "<?php";
            var end_script = "?>";
            var in_script = false;
            do {
                if (startsWith(start_script)) {
                    in_script = true
                } else if (startsWith(end_script)) {
                    in_script = false;
                    s += source.substr(i, end_script.length);
                    i += end_script.length;
                    if (i >= len)break;
                    continue
                }
                var ch = source.charAt(i);
                if (in_script) {
                    s += ch
                } else {
                    if (!func(ch, s)) {
                        return s
                    } else {
                        s += ch;
                        var attr_html_mode = false;
                        if (parse_quotes && (ch == '"' || ch == "'")) {
                            var quote = ch;
                            var escaped = false;
                            i++;
                            while (i < len) {
                                ch = source.charAt(i);
                                if (ch == quote && !escaped) {
                                    s += ch;
                                    break
                                }
                                if (attr_mode && ch == "<") {
                                    attr_html_mode = true
                                } else if (attr_mode && ch == ">" && !attr_html_mode) {
                                    return s
                                }
                                if (!escaped && ch == "\\") {
                                } else {
                                    escaped = false
                                }
                                s += ch;
                                i++
                            }
                        }
                    }
                }
                i++
            } while (i < len);
            return s
        };
        var readUntilIncluding = function (tok) {
            var attrs = null;
            var end = source.indexOf(tok, i);
            if (end < 0) {
                attrs = source.substr(i, len - i);
                i = len - 1
            } else {
                attrs = source.substr(i, end - i + tok.length - 1);
                i = end + tok.length - 1
            }
            return attrs
        };
        var doBatch = function () {
            var start_ms = (new Date).getTime();
            var chunk_max_time = 50;
            var chunks_pi = 100;
            var m = 0;
            while (i < len) {
                var idx = source.indexOf("<", i);
                if (idx < 0) {
                    var textNode = new pgParserNode;
                    textNode.tagName = "text";
                    textNode.content = source.substr(i);
                    textNode.closingTag = textNode.tagName;
                    textNode.textNode = true;
                    textNode.document = _this.rootNode;
                    if (textNode.content.length) {
                        currentNode.addChild(textNode)
                    }
                    i = len
                } else {
                    if (idx > i) {
                        var textContent = source.substr(i, idx - i).split("\n");
                        for (var ti = 0; ti < textContent.length; ti++) {
                            var textNode = new pgParserNode;
                            textNode.tagName = "text";
                            textNode.content = (ti > 0 ? "\n" : "") + textContent[ti];
                            textNode.closingTag = textNode.tagName;
                            textNode.textNode = true;
                            textNode.document = _this.rootNode;
                            if (textNode.content.length) {
                                currentNode.addChild(textNode)
                            }
                        }
                    }
                    i = idx + 1;
                    var tag = readToken(tokenGetTagName);
                    var attrs;
                    var comment = false;
                    if (tag.charAt(0) == "!" && tag.indexOf("!--") == 0) {
                        attrs = readUntilIncluding("-->");
                        comment = true
                    } else if (tag == "?php") {
                        attrs = readUntilIncluding("?>");
                        if (attrs.length) {
                            attrs = attrs.substr(0, attrs.length - 1)
                        }
                    } else {
                        attrs = readToken(tokenGetTagAttributes, true, true)
                    }
                    var selfClosedWithSlash = false;
                    if (attrs.length && attrs.charAt(attrs.length - 1) == "/") {
                        selfClosedWithSlash = true;
                        attrs = attrs.substr(0, attrs.length - 1)
                    }
                    var isSingleTag = _this.singleTags.indexOf(tag.toLowerCase()) >= 0 || selfClosedWithSlash;
                    if (comment) {
                        isSingleTag = true
                    }
                    i++;
                    if (tag.charAt(0) != "/") {
                        node = new pgParserNode;
                        node.tagName = tag.toLowerCase();
                        node.tagNameOriginal = tag;
                        if (tag == "?php") {
                            node.script = true;
                            node.content = attrs;
                            attrs = null
                        } else {
                            node.script = false
                        }
                        node.attributes = attrs;
                        node.comment = comment;
                        node.document = _this.rootNode;
                        node.selfClosed = selfClosedWithSlash;
                        node.isElement = !node.script && !node.comment && node.tagName.charAt(0) != "!";
                        currentNode.addChild(node);
                        if (isSingleTag) {
                            node.singleTag = true;
                            node.closed = true
                        } else {
                            nodeLevels.push(currentNode);
                            currentNode = node
                        }
                        if (tag == "script" || tag == "php") {
                            node.content = readUntilIncluding("</" + tag + ">");
                            node.closingTag = tag;
                            if (node.content.length >= tag.length + 2) {
                                node.content = node.content.substr(0, node.content.length - tag.length - 2)
                            }
                            node.closed = true;
                            currentNode = nodeLevels.pop();
                            i++
                        }
                        var id = node.getId();
                        if (_this.assignIds && node.shouldHaveId()) {
                            if (!id) {
                                id = node.assignId()
                            } else if (_this.replaceExistingIds) {
                                var nid = node.assignId();
                                _this.replacedIds.push({old: id, "new": nid});
                                id = nid
                            }
                            if (parseInt(id) > pgIdCount)pgIdCount = parseInt(id);
                            _this.nodeCatalogue.add(node)
                        }
                        node.getAttrList()
                    } else {
                        var closedTag = tag.replace("/", "").toLowerCase();
                        if (currentNode.tagName == closedTag) {
                            currentNode.closingTag = tag.replace("/", "");
                            currentNode.closed = true;
                            currentNode = nodeLevels.length ? nodeLevels.pop() : currentNode
                        } else {
                            var closedLevel = -1;
                            for (var idx = nodeLevels.length - 1; idx >= 0; idx--) {
                                if (nodeLevels[idx].tagName == closedTag) {
                                    closedLevel = idx;
                                    nodeLevels[idx].closingTag = tag.replace("/", "");
                                    nodeLevels[idx].closed = true;
                                    break
                                }
                            }
                            if (closedLevel >= 0) {
                                while (nodeLevels.length > closedLevel + 0) {
                                    var node = nodeLevels.pop();
                                    node.closed = true;
                                    if (_this.closingTags[node.tagName] && node.children.length) {
                                        if (node.tagName == "option") {
                                            ii = ii
                                        }
                                        var ii = 0;
                                        var last = node;
                                        while (ii < node.children.length) {
                                            if (_this.closingTags[node.tagName].indexOf(node.children[ii].tagName) >= 0) {
                                                last = node.children[ii].insertAfter(last)
                                            } else {
                                                ii++
                                            }
                                        }
                                    }
                                }
                                currentNode = nodeLevels.length ? nodeLevels.pop() : currentNode
                            } else {
                                currentNode.closingTag = tag.replace("/", "");
                                currentNode.closed = true;
                                currentNode = nodeLevels.length ? nodeLevels.pop() : currentNode
                            }
                        }
                    }
                }
                m++;
                if (m % 10 == 0 && done) {
                    var elapsed_ms = (new Date).getTime() - start_ms;
                    if (elapsed_ms >= chunk_max_time) {
                        if (chunkDone)chunkDone();
                        setTimeout(doBatch, 10);
                        break
                    }
                }
            }
            if (i >= len && done)done()
        };
        doBatch()
    };
    this.find = function (sel) {
        return this.rootNode.find(sel)
    };
    this.toStringOriginal = function (format_html, options, func) {
        return this.rootNode.toStringOriginal(format_html, options, func)
    };
    this.toStringWithIds = function (format_html, options, func) {
        return this.rootNode.toStringWithIds(format_html, options, func)
    };
    this.validate = function () {
        return this.rootNode.validateTree()
    }
};